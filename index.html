<body style="background: white"></body>
<video id="myVideo" autoplay></video>
<canvas id="myCanvas"></canvas>
<style>
  #myVideo, #myCanvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%)
  }
  #myVideo {
    z-index: 1
  }
  #myCanvas {
    z-index: 2
  }
</style>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/libs/nn.min.js"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>

<!-- Require the peer dependencies of hand-pose-detection. -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>

<!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>

<script>
/* global Tone, nn, viz */
  
// Hand-Pose Detection Model
  
const video = document.getElementById("myVideo")
const canvas = document.getElementById("myCanvas")
const ctx = canvas.getContext("2d")


video.style.width = nn.width / 1.5 + "px"
video.style.height = (nn.width / 1.5) * 3 / 4 + "px"

video.style.objectFit = "fill"
canvas.width = nn.width / 1.5
canvas.height = (nn.width / 1.5) * 3 / 4
canvas.style.width = nn.width / 1.5 + "px"
canvas.style.height = (nn.width / 1.5) * 3 / 4 + "px"
  


let hand_detector = 0
  
async function setup_webcam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: false
  })
  
  video.srcObject = stream
  
  video.play()
}
  
function create_scaling(){
  scale_x = canvas.width / video.videoWidth
  scale_y = canvas.height / video.videoHeight
}

video.addEventListener("loadedmetadata", create_scaling)

  
async function load_model(){
  const hand_pose_model = handPoseDetection.SupportedModels.MediaPipeHands

  const detectorConfig = {
    runtime: "mediapipe",
    solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
    modelType: "full"
  }

  hand_detector = await handPoseDetection.createDetector(hand_pose_model, detectorConfig)
}

  
const left_speed_list = []
const right_speed_list = []

const smoothing_length = 30
let left_pre_position = 0
let right_pre_position = 0
let conducting_mode = "off"
  
function cal_speed(position, handedness){
  let instant_speed = 0
  
  if (handedness === "Left"){
    
    if (left_pre_position !== 0){
      const dx = position.x - left_pre_position.x
      const dy = position.y - left_pre_position.y

      instant_speed = Math.sqrt(dx * dx + dy * dy)
    }

    left_pre_position = {x: position.x, y: position.y}
    
    left_speed_list.push(instant_speed)
  
    if (left_speed_list.length > smoothing_length){
      left_speed_list.shift()
    }

    let speed_sum = 0
    for (let speed of left_speed_list){
      speed_sum += speed
    }

    return speed_sum / left_speed_list.length
  } else {
    if (right_pre_position !== 0){
      const dx = position.x - right_pre_position.x
      const dy = position.y - right_pre_position.y

      instant_speed = Math.sqrt(dx * dx + dy * dy)
    }

    right_pre_position = {x: position.x, y: position.y}
    
    right_speed_list.push(instant_speed)
  
    if (right_speed_list.length > smoothing_length){
      right_speed_list.shift()
    }

    let speed_sum = 0
    for (let speed of right_speed_list){
      speed_sum += speed
    }

    return speed_sum / right_speed_list.length
  }
  
  
}
  
function cal_dist(pos1, pos2){
  const dx = pos1.x - pos2.x
  const dy = pos1.y - pos2.y
  return Math.sqrt(dx * dx + dy * dy)
}
  
let frame_passed = 0
  
async function get_pose(){
  const hand_pose = await hand_detector.estimateHands(video)
  
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  
  hand_pose.forEach(hand => {
    hand.keypoints.forEach(keypoint => {
      ctx.beginPath()
      ctx.arc(keypoint.x * scale_x, keypoint.y * scale_y, 5, 0, 2 * Math.PI)
      ctx.fillStyle = "blue"
      ctx.fill()
      // console.log(keypoint.x, keypoint.y)
      
      // ctx.fillStyle = "white"
      // ctx.font = "10px Arial"
      // ctx.fillText(keypoint.name, keypoint.x + 5, keypoint.y + 5)
    })
    
    if (hand.handedness === "Left" && conducting_mode === "on"){
      const thumb = hand.keypoints[4]

      const smoothed_speed = cal_speed(thumb, "Left")
      
      if (smoothed_speed <= 2) {
        Tone.Transport.bpm.value = 0
      } else if (smoothed_speed <= 10) {
        Tone.Transport.bpm.value = 100
      } else if (smoothed_speed <= 15) {
        Tone.Transport.bpm.value = 220
      } else {
        Tone.Transport.bpm.value = 300
      }

      ctx.fillStyle = "yellow"

      ctx.font = "20px Arial"

      ctx.fillText(`right thumb speed: ${smoothed_speed.toFixed(2)}`, 10, 20)
      
    }
    
    if (hand.handedness === "Right" && conducting_mode === "on"){
      const thumb = hand.keypoints[4]
      const point = hand.keypoints[8]

      const smoothed_speed = cal_speed(thumb, "Right")

      ctx.fillStyle = "yellow"

      ctx.font = "20px Arial"

      ctx.fillText(`left distance ${cal_dist(thumb, point).toFixed(2)}`, canvas.width / 2 , 20)
      
      if (cal_dist(thumb, point) <= 30 && frame_passed >= 50) {
        drumset.player("hihat").start()
        frame_passed = 0
      }
      
    }
    frame_passed += 1
  })
  
  requestAnimationFrame(get_pose)
}
  
async function hand_pose_setup(){
  await setup_webcam()
  await load_model()
  await get_pose()
}

hand_pose_setup()
  
// load_model()
// setup_webcam()
  


// SOURCES
// ------------------

const synth = new Tone.PolySynth()

const path = 'https://tonejs.github.io/audio/drum-samples/Stark/'
const drumset = new Tone.Players({
  kick: path + 'kick.mp3',
  snare: path + 'snare.mp3',
  hihat: path + 'hihat.mp3',
  tom1: path + 'tom1.mp3',
  tom2: path + 'tom2.mp3',
  tom3: path + 'tom3.mp3'
})

const list_players = ["kick", "snare", "hihat", "tom1", "tom2", "tom3"]

const possible_notes = ["C", "D", "E", "F", "G", "A", "B"]

// SIGNAL CHAIN
// -------------------
synth.toDestination()
drumset.toDestination()

// TRANSPORT SETUP + OTHER GLOBAL VARS
// ------------------------------------

Tone.Transport.bpm.value = 200
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '10m'
  
// FUNCTIONS 
// -----------------
  
// the chance calculation 
function cal_chance(player, bar, beat){
  if (player === "kick") {
    if (bar < 5) {
      return 0
    }
    else {
      if (beat % 4 === 0) {
        return nn.random()
      } else {
        return nn.random(0, 0.55)
      }
    }
  }

  if (player === "snare") {
    if (bar < 5) {
      if (beat % 4 === 0) {
        return 1
      } else {
        return nn.random(0, 0.55)
      }
    }
    else {
      return nn.random(0, 0.8) 
    }
  }

  if (player === "hihat") {
    if (bar < 5) {
      return 0
    }
    else {
      return nn.random(0, 0.6)
    }
  }

  if (player === "tom1") {
    if (bar < 5) {
      if (beat % 2 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 1.1)
    }
  }

  if (player === "tom2") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      return nn.random()
    }
  }

  if (player === "tom3") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      if (nn.random(0, 1) > 0.2) {
        return 2
      } else {
        return nn.random()
      }
    }
  }
}
  
let previous_root_index = 0

function play (time) {
  const [bar, beat] = Tone.Transport.position.split(':').map(Number)
  
  // ............................
  // musical algorithm goes here
  // ............................
  
  
  for (const player of list_players){
    if (cal_chance(player, bar, beat) > 0.5) {
      drumset.player(player).start(time)
    }
    if (cal_chance(player, bar, beat) > 1) {
      drumset.player(player).start(time + (30 / Tone.Transport.bpm.value))
    }
  }
  
  let [root, scale, root_index] = [0, 0, 0]
  
  const possible_chords = ["power-chord", "triad", "seventh"]
  
  if (beat % 4 === 0){
    root_index = nn.randomInt(0, 6)
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
    previous_root_index = root_index
  } else if (beat % 4 === 1){
    root_index = (previous_root_index + 1) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  } else if (beat % 4 === 2){
    root_index = (previous_root_index + 3) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  }
  else {
    root_index = (previous_root_index + 2) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  }
  
  const lower_root = possible_notes[root_index] + 3
  const lower_scale = nn.createScale(lower_root, "major")
  
  
  let length
  
  if (bar < 5){
    length = nn.random(["16n", "8n"])
  } else {
    length = nn.random(["8n", "4n"])
  }

  let chord = nn.createChord(scale, nn.random(possible_chords))
  
  let lower_chord = nn.createChord(lower_scale, "triad")
  
  synth.triggerAttackRelease(chord, length, time)
  synth.triggerAttackRelease(lower_chord, "8n", time)
}

// SETUP PLAY LOOP
// ----------------------
  
  
function change_bpm(){
  Tone.Transport.bpm.value = this.value
}


let current_playing = false
let first_time_clicking = true
let player = 0

function start_playing(){
  if (current_playing){
    player.stop()
    Tone.Transport.stop()
    current_playing = false
    this.content("restart music")
  } else if (first_time_clicking) {

    player = new Tone.Loop(play).start()
    Tone.Transport.start()

    nn.create("button")
      .content("switch to conducting mode")
      .css({
      "position": "absolute",
      "left": 10,
      "top": 30,
      "z-index": 3,
    })
      .addTo("body")
      .on("click", change_mode)

    const input_bpm = nn.create("input")
                      .addTo("body")
                      .css({
                        "position": "absolute",
                        "left": 380,
                        "top": 30,
                        "z-index": 3,
                        "color": "blue"
                      })
                      .on("change", change_bpm)
    
    nn.create("label")
      .content("customize the bpm:")
      .css({
            "position": "absolute",
            "left": 200,
            "top": 30,
            "z-index": 3,
      })
      .addTo("body")
    
    current_playing = true
    first_time_clicking = false
    this.content("stop music")
    }
  else {
    player.start()
    Tone.Transport.start()
    current_playing = true
    this.content("stop music")
  }
}


function change_mode(){
  if (conducting_mode === "off"){
    conducting_mode = "on"
    Tone.Transport.bpm.value = 0
    this.content("switch to automated mode")
  } else{
    conducting_mode = "off"
    Tone.Transport.bpm.value = 200
    this.content("switch to conducting mode")
  }
}
  
nn.create("button")
  .content("Start playing music and explore conducting music on your own")
  .css({
  "position": "absolute",
  "left": 10,
  "top": 10,
  "z-index": 3,
})
  .addTo("body")
  .on("click", start_playing)

  
let instrustions_on = false

const instructions = nn.create("label")
                      .content(" ")
                      .css({
                      "position": "absolute",
                      "left": 0,
                      "top": nn.height - 100,
                      "z-index": 4,
                      "color": "red"
                    })
                      .addTo("body")

function instructions_mode(){
  if (instrustions_on){
    instructions.content(" ")
    instrustions_on = false
    this.content("Open Instructions")
  }
  else{
    instructions.content("When in conducting mode, use your right hand thumb movement speed to control speed of music and put together your left hand's thumb and index finger to hit a hihat.")
    instrustions_on = true
    this.content("Close Instructions")
  }
}
  
nn.create("button")
  .content("Open Instructions")
  .css({
  "position": "absolute",
  "left": 500,
  "top": 10,
  "z-index": 3,
})
  .addTo("body")
  .on("click", instructions_mode)


  

</script>