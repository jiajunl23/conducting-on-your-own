<body style="background: white"></body>
<video id="myVideo" autoplay></video>
<canvas id="myCanvas"></canvas>
<style>
  #myVideo, #myCanvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%)
  }
  #myVideo {
    z-index: 1
  }
  #myCanvas {
    z-index: 2
  }
</style>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/libs/nn.min.js"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>

<!-- Require the peer dependencies of hand-pose-detection. -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>

<!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>

<script>
/* global Tone, nn, viz */
  
// Hand-Pose Detection Model
  
const video = document.getElementById("myVideo")
const canvas = document.getElementById("myCanvas")
const ctx = canvas.getContext("2d")


video.style.width = nn.width / 1.2 + "px"
video.style.height = nn.height / 1.2 + "px"
canvas.style.width = nn.width / 1.2 + "px"
canvas.style.height = nn.height / 1.2 + "px"

let hand_detector = 0
  
async function setup_webcam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: false
  })
  
  video.srcObject = stream
  
  video.play()
}


  
async function load_model(){
  const hand_pose_model = handPoseDetection.SupportedModels.MediaPipeHands

  const detectorConfig = {
    runtime: "mediapipe",
    solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
    modelType: "full"
  }

  hand_detector = await handPoseDetection.createDetector(hand_pose_model, detectorConfig)
}

  
const left_speed_list = []
const right_speed_list = []

const smoothing_length = 30
let left_pre_position = 0
let right_pre_position = 0
let conducting_mode = "off"
  
function cal_speed(position, handedness){
  let instant_speed = 0
  
  if (handedness === "Left"){
    
    if (left_pre_position !== 0){
      const dx = position.x - left_pre_position.x
      const dy = position.y - left_pre_position.y

      instant_speed = Math.sqrt(dx * dx + dy * dy)
    }

    left_pre_position = {x: position.x, y: position.y}
    
    left_speed_list.push(instant_speed)
  
    if (left_speed_list.length > smoothing_length){
      left_speed_list.shift()
    }

    let speed_sum = 0
    for (let speed of left_speed_list){
      speed_sum += speed
    }

    return speed_sum / left_speed_list.length
  } else {
    if (right_pre_position !== 0){
      const dx = position.x - right_pre_position.x
      const dy = position.y - right_pre_position.y

      instant_speed = Math.sqrt(dx * dx + dy * dy)
    }

    right_pre_position = {x: position.x, y: position.y}
    
    right_speed_list.push(instant_speed)
  
    if (right_speed_list.length > smoothing_length){
      right_speed_list.shift()
    }

    let speed_sum = 0
    for (let speed of right_speed_list){
      speed_sum += speed
    }

    return speed_sum / right_speed_list.length
  }
  
  
}
  
let frame_passed = 0
  
async function get_pose(){
  const hand_pose = await hand_detector.estimateHands(video)
  
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  
  hand_pose.forEach(hand => {
    hand.keypoints.forEach(keypoint => {
      ctx.beginPath()
      ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI)
      ctx.fillStyle = "blue"
      ctx.fill()
      // console.log(keypoint.x, keypoint.y)
      
      // ctx.fillStyle = "white"
      // ctx.font = "10px Arial"
      // ctx.fillText(keypoint.name, keypoint.x + 5, keypoint.y + 5)
    })
    
    if (hand.handedness === "Left" && conducting_mode === "on"){
      const thumb = hand.keypoints[4]

      const smoothed_speed = cal_speed(thumb, "Left")
      
      if (smoothed_speed <= 2) {
        Tone.Transport.bpm.value = 0
      } else if (smoothed_speed <= 10) {
        Tone.Transport.bpm.value = 100
      } else if (smoothed_speed <= 15) {
        Tone.Transport.bpm.value = 220
      } else {
        Tone.Transport.bpm.value = 300
      }

      ctx.fillStyle = "yellow"

      ctx.font = "20px Arial"

      ctx.fillText(`right thumb speed: ${smoothed_speed.toFixed(2)}`, 10, 30)
      
    }
    
    if (hand.handedness === "Right" && conducting_mode === "on"){
      const thumb = hand.keypoints[4]

      const smoothed_speed = cal_speed(thumb, "Right")

      ctx.fillStyle = "yellow"

      ctx.font = "20px Arial"

      ctx.fillText(`left thumb speed: ${smoothed_speed.toFixed(2)}`, 320, 30)
      
      if (smoothed_speed >= 5 && frame_passed >= 100) {
        drumset.player("hihat").start()
        frame_passed = 0
      }
    }
    frame_passed += 1
  })
  
  requestAnimationFrame(get_pose)
}
  
async function hand_pose_setup(){
  await setup_webcam()
  await load_model()
  await get_pose()
}

hand_pose_setup()
  
// load_model()
// setup_webcam()
  


// SOURCES
// ------------------

const synth = new Tone.PolySynth()

const path = 'https://tonejs.github.io/audio/drum-samples/Stark/'
const drumset = new Tone.Players({
  kick: path + 'kick.mp3',
  snare: path + 'snare.mp3',
  hihat: path + 'hihat.mp3',
  tom1: path + 'tom1.mp3',
  tom2: path + 'tom2.mp3',
  tom3: path + 'tom3.mp3'
})

const list_players = ["kick", "snare", "hihat", "tom1", "tom2", "tom3"]

const possible_notes = ["C", "D", "E", "F", "G", "A", "B"]

// SIGNAL CHAIN
// -------------------
synth.toDestination()
drumset.toDestination()

// TRANSPORT SETUP + OTHER GLOBAL VARS
// ------------------------------------

Tone.Transport.bpm.value = 200
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '10m'
  
// FUNCTIONS 
// -----------------
  
// the chance calculation 
function cal_chance(player, bar, beat){
  if (player === "kick") {
    if (bar < 5) {
      return 0
    }
    else {
      if (beat % 4 === 0) {
        return nn.random()
      } else {
        return nn.random(0, 0.55)
      }
    }
  }

  if (player === "snare") {
    if (bar < 5) {
      if (beat % 4 === 0) {
        return 1
      } else {
        return nn.random(0, 0.55)
      }
    }
    else {
      return nn.random(0, 0.8) 
    }
  }

  if (player === "hihat") {
    if (bar < 5) {
      return 0
    }
    else {
      return nn.random(0, 0.6)
    }
  }

  if (player === "tom1") {
    if (bar < 5) {
      if (beat % 2 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 1.1)
    }
  }

  if (player === "tom2") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      return nn.random()
    }
  }

  if (player === "tom3") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      if (nn.random(0, 1) > 0.2) {
        return 2
      } else {
        return nn.random()
      }
    }
  }
}
  
let previous_root_index = 0

function play (time) {
  const [bar, beat] = Tone.Transport.position.split(':').map(Number)
  
  // ............................
  // musical algorithm goes here
  // ............................
  
  
  for (const player of list_players){
    if (cal_chance(player, bar, beat) > 0.5) {
      drumset.player(player).start(time)
    }
    if (cal_chance(player, bar, beat) > 1) {
      drumset.player(player).start(time + (30 / Tone.Transport.bpm.value))
    }
  }
  
  let [root, scale, root_index] = [0, 0, 0]
  
  const possible_chords = ["power-chord", "triad", "seventh"]
  
  if (beat % 4 === 0){
    root_index = nn.randomInt(0, 6)
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
    previous_root_index = root_index
  } else if (beat % 4 === 1){
    root_index = (previous_root_index + 1) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  } else if (beat % 4 === 2){
    root_index = (previous_root_index + 3) % 7
    root = possible_notes[root_index] + nn.randomInt(3, 4)
    scale = nn.createScale(root, "major")
  }
  else {
    root_index = (previous_root_index + 2) % 7
    root = possible_notes[root_index] + nn.randomInt(3, 4)
    scale = nn.createScale(root, "major")
  }
  
  
  let length
  
  if (bar < 5){
    length = nn.random(["16n", "8n"])
  } else {
    length = nn.random(["8n", "4n"])
  }

  let chord = nn.createChord(scale, nn.random(possible_chords))
  
  synth.triggerAttackRelease(chord, length, time)
}

// SETUP PLAY LOOP
// ----------------------
new Tone.Loop(play).start()
  
Tone.Transport.start()

function change_mode(){
  if (conducting_mode === "off"){
    conducting_mode = "on"
    Tone.Transport.bpm.value = 0
    this.content("switch to automated mode")
  } else{
    conducting_mode = "off"
    Tone.Transport.bpm.value = 200
    this.content("switch to conducting mode")
  }
}
  
nn.create("button")
  .content("switch to conducting mode")
  .css({
  "position": "absolute",
  "left": 10,
  "top": 10,
  "z-index": 3,
})
  .addTo("body")
  .on("click", change_mode)

function change_bpm(){
  Tone.Transport.bpm.value = this.value
}

nn.create("label")
  .content("customize the bpm:")
  .css({
        "position": "absolute",
        "left": 200,
        "top": 10,
        "z-index": 3,
  })
  .addTo("body")
  
const input_bpm = nn.create("input")
                  .addTo("body")
                  .css({
                    "position": "absolute",
                    "left": 380,
                    "top": 10,
                    "z-index": 3,
                    "color": "blue"
                  })
                  .on("change", change_bpm)

</script>