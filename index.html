<body style="background: white"></body>
<video id="myVideo" width="640" height="480" autoplay></video>
<canvas id="myCanvas" width="640" height="480"></canvas>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/libs/nn.min.js"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>

<!-- Require the peer dependencies of hand-pose-detection. -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>

<!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>

<script>
/* global Tone, nn, viz */
  
// Hand-Pose Detection Model
  
const video = document.getElementById("myVideo")
const canvas = document.getElementById("myCanvas")
const ctx = canvas.getContext("2d")

let hand_detector = 0
  
async function setup_webcam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: false
  })
  
  video.srcObject = stream
  
  video.play()
}
  
async function load_model(){
  const hand_pose_model = handPoseDetection.SupportedModels.MediaPipeHands

  const detectorConfig = {
    runtime: "mediapipe",
    solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
    modelType: "full"
  }

  hand_detector = await handPoseDetection.createDetector(hand_pose_model, detectorConfig)
}
  
async function get_pose(){
  const hand_pose = await hand_detector.estimateHands(video)
  
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  
  hand_pose.forEach(hand => {
    hand.keypoints.forEach(keypoint => {
      ctx.beginPath()
      ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI)
      ctx.fillstyle = "blue"
      ctx.fill()
      console.log(keypoint.x, keypoint.y)
      
      ctx.fillStyle = "white"
      ctx.font = "10px Arial"
      ctx.fillText(keypoint.name, keypoint.x + 5, keypoint.y + 5)
    })
  })
  
  if (hand_pose[0]) {
    // console.log(hand_pose)
  }
  
  requestAnimationFrame(get_pose)
}
  
async function hand_pose_setup(){
  await setup_webcam()
  await load_model()
  await get_pose()
}

// hand_pose_setup()
  
// load_model()
// setup_webcam()
  


// SOURCES
// ------------------

const synth = new Tone.PolySynth()

const path = 'https://tonejs.github.io/audio/drum-samples/Stark/'
const drumset = new Tone.Players({
  kick: path + 'kick.mp3',
  snare: path + 'snare.mp3',
  hihat: path + 'hihat.mp3',
  tom1: path + 'tom1.mp3',
  tom2: path + 'tom2.mp3',
  tom3: path + 'tom3.mp3'
})

const list_players = ["kick", "snare", "hihat", "tom1", "tom2", "tom3"]

const possible_notes = ["C", "D", "E", "F", "G", "A", "B"]

// SIGNAL CHAIN
// -------------------
synth.toDestination()
drumset.toDestination()

// TRANSPORT SETUP + OTHER GLOBAL VARS
// ------------------------------------

Tone.Transport.bpm.value = 240
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '10m'
  
// FUNCTIONS 
// -----------------
  
// the chance calculation 
function cal_chance(player, bar, beat){
  if (player === "kick") {
    if (bar < 5) {
      return 0
    }
    else {
      if (beat % 4 === 0) {
        return nn.random()
      } else {
        return 0
      }
    }
  }

  if (player === "snare") {
    if (bar < 5) {
      if (beat % 4 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 0.8) 
    }
  }

  if (player === "hihat") {
    if (bar < 5) {
      return 0
    }
    else {
      if (nn.random() > 0.8){
        return 0
      } else{
        return 0
      }
    }
  }

  if (player === "tom1") {
    if (bar < 5) {
      if (beat % 2 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 1.1)
    }
  }

  if (player === "tom2") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      return nn.random()
    }
  }

  if (player === "tom3") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      if (nn.random(0, 1) > 0.2) {
        return 2
      } else {
        return nn.random()
      }
    }
  }
}

function toggle () {
  if (Tone.Transport.state === 'stopped') {
    Tone.Transport.start()
    this.content('stop')
  } else {
    Tone.Transport.stop()
    this.content('start')
  }
}

function pressPianoKey (note, dur, time) {
  const delay = time + Tone.Time(dur).toSeconds()
  Tone.Draw.schedule(() => pianoKeys.attack(note), time)
  Tone.Draw.schedule(() => pianoKeys.release(note), delay)
}
  
let previous_root_index = 0

function play (time) {
  const [bar, beat] = Tone.Transport.position.split(':').map(Number)
  
  // ............................
  // musical algorithm goes here
  // ............................
  
  
  for (const player of list_players){
    if (cal_chance(player, bar, beat) > 0.5) {
      drumset.player(player).start(time)
    }
    if (cal_chance(player, bar, beat) > 1) {
      drumset.player(player).start(time + (30 / Tone.Transport.bpm.value))
    }
  }
  
  let [root, scale, root_index] = [0, 0, 0]
  
  const possible_chords = ["power-chord", "triad", "seventh"]
  
  if (beat % 2 === 0){
    root_index = nn.randomInt(0, 6)
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
    previous_root_index = root_index
  } else {
    root_index = (previous_root_index + 1) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  }
  
  
  let length
  
  if (bar < 5){
    length = nn.random(["16n", "8n"])
  } else {
    length = nn.random(["8n", "4n"])
  }
        

  let chord = nn.createChord(scale, nn.random(possible_chords))
  synth.triggerAttackRelease(chord, length, time)
  
  chord.forEach(note => {
    pressPianoKey(note, length, time)
  })
}


// SETUP PLAY LOOP
// ----------------------
new Tone.Loop(play).start()

// USER INTERFACE
// ---------------------
const toggleBtn = nn.create('button')
  .content('start')
  .addTo('body')
  .on('click', toggle)

nn.create('br').addTo('body')

const pianoKeys = viz.createPianoUI({
  labels: true,
  octaves: [3, 6]
})

</script>